----------------------------------------------------------
ch01.策略模式(strategy)
1.1.定义:策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，
此模式让算法的变化独立于使用算法的客户。

1.2.所在包:
    headfirst.strategy
    对应PNG:Ch01_策略模式001.png

1.3.备注:
    a,利用继承来提供Duck的行为,这会导致下列缺点
        代码在多个子类中重复
        很难知道所有鸭子的全部行为
        运行时的行为不容易改变
        改变会牵一发动全身,造成其他鸭子不想要的改变.
    b,不仅可将算法族封装成类,更可以在运行时动态地改变行为.

----------------------------------------------------------
Ch02.观察者模式(observer)
2.1.定义:观察者模式定义了对象之间一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖都会收到通知并自动更新.

2.2.所在包:
    a,headfirst.observer.weather
    对应PNG:Ch02_观察者模式001.png
    观察者模式具体实现的单线程版本.
    
    b,headfirst.observer.weatherobservable
    对应PNG:Ch02_观察者模式002.png
    使用Java内置的观察者模式,!!!Observable类和Observer接口
    
    c,headfirst.observer.swing
    一个JDK中简单的例子:按钮是主题,actionlistener是观察者.
    
2.3.备注:
    a,只要主题与观察者之间的接口仍被遵守,其中一方的改变不会影响另一方.
    b,主题只知道观察实现了某个接口.主题不需要知道观察者的具体类型是什么,做了什么或其它任何细节.
    
----------------------------------------------------------
Ch03.装饰者模式(decorator)
3.1.定义:装饰者模式动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案.

3.2.所在包:
    a,headfirst.decorator.starbuzz
    对应PNG:Ch03_装饰者模式_抽象.png,Ch03_装饰者模式_具体例子.png
    
    b,headfirst.decorator.io
    一个JDK中简单的使用:自定义IO流(装饰者),将大字字母转换成小写的Stream.

3.3.备注:
    a,可以做到在不直接修改代码的情况下进行功能的扩展.
    b,缺点:类太多;有些代码会依赖特定的类型.如果这样的代码一导入装饰者,就会出现混乱的状况.

----------------------------------------------------------
Ch04.工厂模式(factory)
4.1.定义:
    a,简单工厂:(简单工厂不是一个设计模式,经常被使用!!)
    b,
    c,

4.2.所在包:
    a,headfirst.factory.pizzas      (简单工厂)
    对应PNG:
    
    
    
    